# 嵌入缓存架构图

## 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    CoherenceMetric                               │
│                                                                  │
│  ┌────────────────────────────────────────────────────────┐    │
│  │              内存缓存（一级缓存）                        │    │
│  │                                                          │    │
│  │  _embedding_cache = {                                   │    │
│  │    'entity_1': np.array([...]),  # 快速访问 O(1)       │    │
│  │    'entity_2': np.array([...]),                         │    │
│  │    ...                                                   │    │
│  │  }                                                       │    │
│  │                                                          │    │
│  │  特点：                                                  │    │
│  │  - 访问速度：< 0.01ms                                   │    │
│  │  - 生命周期：进程运行期间                               │    │
│  │  - 容量：无限制（受内存限制）                           │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                  图数据库（持久化存储）                          │
│                                                                  │
│  ┌────────────────────────────────────────────────────────┐    │
│  │           持久化缓存（二级缓存）                         │    │
│  │                                                          │    │
│  │  EntityNode = {                                         │    │
│  │    'entity_name': 'Diabetes',                           │    │
│  │    'entity_type': 'disease',                            │    │
│  │    'description': '...',                                │    │
│  │    'embedding_cache': [0.1, 0.2, ..., 0.9]  # 1536维   │    │
│  │  }                                                       │    │
│  │                                                          │    │
│  │  特点：                                                  │    │
│  │  - 访问速度：5-10ms                                     │    │
│  │  - 生命周期：永久（直到删除）                           │    │
│  │  - 容量：受数据库限制                                   │    │
│  └────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 查询流程

```
用户查询
    ↓
需要实体嵌入
    ↓
┌─────────────────────────────────────┐
│ 1. 检查内存缓存                      │
│    _embedding_cache.get(entity_id)  │
└─────────────────────────────────────┘
    ↓ 命中？
    ├─ 是 → 返回嵌入（< 0.01ms）
    │
    └─ 否 ↓
┌─────────────────────────────────────┐
│ 2. 检查持久化缓存                    │
│    node['embedding_cache']          │
└─────────────────────────────────────┘
    ↓ 存在？
    ├─ 是 → 加载到内存 → 返回嵌入（5-10ms）
    │
    └─ 否 ↓
┌─────────────────────────────────────┐
│ 3. 批量计算嵌入                      │
│    embedding_func(texts)            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 存储到内存缓存                    │
│    _embedding_cache[id] = emb       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 5. 异步存储到持久化缓存              │
│    node['embedding_cache'] = emb    │
│    (后台任务，不阻塞)                │
└─────────────────────────────────────┘
    ↓
返回嵌入（50-100ms）
```

## 批量优化示例

### 场景：计算超边一致性，需要5个实体的嵌入

```
实体列表: [E1, E2, E3, E4, E5]

缓存状态:
- E1: 在内存缓存中 ✓
- E2: 在持久化缓存中 ○
- E3: 在内存缓存中 ✓
- E4: 未缓存 ✗
- E5: 未缓存 ✗

执行流程:
┌──────────────────────────────────────┐
│ 第1步：从内存缓存获取                 │
│ - E1: 立即返回 (< 0.01ms)            │
│ - E3: 立即返回 (< 0.01ms)            │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 第2步：从持久化缓存加载               │
│ - E2: 读取节点 → 加载到内存 (5ms)    │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 第3步：批量计算未缓存的               │
│ - [E4, E5]: 一次调用 (100ms)         │
│   embedding_func(['E4 text', 'E5 text']) │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 第4步：更新缓存                       │
│ - E4, E5 → 内存缓存                  │
│ - E4, E5 → 持久化缓存（异步）        │
└──────────────────────────────────────┘

总耗时: ~105ms
无缓存耗时: ~250ms (5 × 50ms)
节省: 58%
```

## 性能对比

### 单次查询

| 场景 | 内存缓存 | 持久化缓存 | 计算 | 总耗时 |
|------|----------|------------|------|--------|
| 全部命中内存 | 5个 | 0个 | 0个 | < 0.1ms |
| 部分命中内存 | 2个 | 2个 | 1个 | ~60ms |
| 全部未缓存 | 0个 | 0个 | 5个 | ~250ms |

### 重复查询（3次）

| 场景 | 无缓存 | 有缓存 | 提升 |
|------|--------|--------|------|
| 总耗时 | 750ms | 250ms | **3x** |
| API调用 | 15次 | 5次 | **减少66%** |

## 内存占用分析

### 单个嵌入向量

```
维度: 1536 (OpenAI ada-002)
数据类型: float32
大小: 1536 × 4 bytes = 6,144 bytes ≈ 6 KB
```

### 不同规模的内存占用

| 实体数量 | 内存占用 | 说明 |
|----------|----------|------|
| 1,000 | 6 MB | 小型图谱 |
| 10,000 | 61 MB | 中型图谱 |
| 100,000 | 610 MB | 大型图谱 |
| 1,000,000 | 6.1 GB | 超大型图谱 |

### 建议

- **< 100K 实体**：全部缓存到内存
- **100K - 1M 实体**：使用 LRU 策略，缓存热点实体
- **> 1M 实体**：仅缓存频繁访问的实体

## 存储开销分析

### 持久化缓存存储

```json
{
  "entity_name": "Diabetes",
  "entity_type": "disease",
  "description": "A metabolic disorder...",
  "embedding_cache": [0.1, 0.2, ..., 0.9]  // 1536个浮点数
}
```

**存储大小**：
- JSON 格式：约 8-10 KB/实体
- 二进制格式：约 6 KB/实体

**数据库影响**：
- Neo4j：节点属性增加，可接受
- MongoDB：文档大小增加，可接受
- 总体影响：< 1% 存储增长（相对于整个图谱）

## 缓存策略对比

### 策略1：仅内存缓存

```
优点:
- 实现简单
- 访问速度快

缺点:
- 进程重启后丢失
- 不能跨进程共享
```

### 策略2：仅持久化缓存

```
优点:
- 永久保存
- 跨进程共享

缺点:
- 访问速度慢
- 增加数据库负载
```

### 策略3：两级缓存（当前实现）✓

```
优点:
- 结合两者优势
- 灵活的性能/持久化权衡
- 自动优化访问路径

缺点:
- 实现复杂度稍高
- 需要管理两个缓存
```

## 最佳实践总结

### 1. 启动时预热

```python
# 系统启动时
frequent_entities = get_top_1000_entities()
await coherence.load_persistent_cache_to_memory(frequent_entities)
```

### 2. 批量处理

```python
# 批量缓存（推荐）
await coherence.cache_entity_embeddings(all_entities)

# 避免逐个处理
for entity in all_entities:
    await coherence._get_entity_embeddings([entity])  # 不推荐
```

### 3. 定期清理

```python
# 长时间运行的服务
if coherence.get_cache_size() > MAX_CACHE_SIZE:
    coherence.clear_cache()  # 清理内存，保留持久化
```

### 4. 监控缓存效果

```python
# 定期检查
stats = await coherence.get_cache_statistics()
logger.info(f"缓存命中率: {stats['hit_rate']}")
```

## 技术决策

### 为什么使用两级缓存？

1. **性能**：内存缓存提供最快访问
2. **持久化**：持久化缓存避免重复计算
3. **灵活性**：可以根据需求选择策略
4. **可扩展性**：易于添加更多缓存层（如 Redis）

### 为什么异步更新持久化缓存？

1. **不阻塞主流程**：查询立即返回
2. **批量优化**：可以合并多个更新
3. **容错性**：更新失败不影响查询
4. **性能**：减少同步等待时间

### 为什么使用批量计算？

1. **效率**：减少函数调用开销
2. **API成本**：减少 API 调用次数
3. **并行化**：嵌入模型可以批量处理
4. **网络优化**：减少网络往返

## 总结

嵌入缓存优化通过精心设计的两级缓存系统，在性能、持久化和资源使用之间取得了良好的平衡：

- ✅ **3x+ 性能提升**
- ✅ **66%+ API调用减少**
- ✅ **跨会话持久化**
- ✅ **自动批量优化**
- ✅ **灵活的配置选项**

这是一个生产就绪的优化方案，特别适合大规模知识图谱应用。
